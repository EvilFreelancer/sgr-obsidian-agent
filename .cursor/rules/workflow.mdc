---
description: Workflow rules for development, bug fixes, and new features
globs: src/**/*.ts, src/**/*.tsx, tests/**/*.ts
alwaysApply: true
---

# Workflow Rules

## Test-Driven Development (TDD) Principles

This project follows **Test-Driven Development (TDD)** methodology. All new features and bug fixes must follow the TDD cycle:

### TDD Cycle (Red-Green-Refactor)

1. **üî¥ RED**: Write a failing test first
   - Test describes desired behavior
   - Test must fail for the right reason (not compilation errors)
   - This ensures test is actually testing something

2. **üü¢ GREEN**: Write minimal code to make test pass
   - Implement just enough code to satisfy the test
   - Don't over-engineer at this stage
   - Focus on making test pass

3. **üîµ REFACTOR**: Improve code while keeping tests green
   - Clean up code, improve structure
   - Remove duplication
   - Run tests after each refactoring step

4. **‚úÖ REGRESSION**: Run all tests
   - Ensure no existing functionality broke
   - Fix any regressions before proceeding

### Why TDD?

- **Confidence**: Tests prove code works
- **Documentation**: Tests document expected behavior
- **Design**: Writing tests first leads to better API design
- **Regression prevention**: Full test suite catches breaking changes
- **Faster feedback**: Catch bugs early in development cycle

## General Development Process

### Understanding Requirements
1. Read and understand SPECIFICATION.md
2. Identify which module/component needs to be implemented
3. Check architecture rules for layer placement
4. Review existing code for patterns

### Implementation Approach
- Follow "one class at a time" principle
- Start from lower architecture layers
- Write minimal code that works
- Test incrementally

## New Features (TDD Approach)

### Mandatory Workflow for New Features

**CRITICALLY IMPORTANT**: When user asks to implement a new feature (using words "—Ñ–∏—á–∞", "feature", "–Ω–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è", "–¥–æ–±–∞–≤–∏—Ç—å", "implement", "add"), **always** follow this TDD workflow:

**Do not skip any step!** Always follow order: understand ‚Üí write test ‚Üí verify test fails ‚Üí implement ‚Üí verify test passes ‚Üí run all tests ‚Üí report.

### Step-by-step TDD Process for New Features

1. **Understand requirements**
   - Read SPECIFICATION.md relevant section
   - Identify architecture layer
   - Check dependencies
   - Plan implementation approach

2. **Write test first (RED phase)**
   - Create or update test file in `tests/` directory
   - Write test that describes desired behavior
   - Test should cover main use case and edge cases
   - Follow test structure from @testing.mdc
   - Use mocks for external dependencies
   - Test file should be in appropriate directory (core/, integration/, utils/, etc.)

3. **Verify test fails (RED phase)**
   - Run the test: `npm test` or `npm run test:watch`
   - **CRITICAL**: Test MUST fail at this stage
   - Verify failure is for the right reason (not compilation errors)
   - If test passes without implementation, test is wrong - fix it

4. **Implement minimal code (GREEN phase)**
   - Write minimal code to make test pass
   - Follow rules from @code-style.mdc and @architecture.mdc
   - Use @implementation-order.mdc if adding new classes
   - Add TypeScript types
   - Don't over-engineer - just make test pass

5. **Verify test passes (GREEN phase)**
   - Run the test again: `npm test` or `npm run test:watch`
   - **CRITICAL**: Test MUST pass now
   - Verify all assertions in test are satisfied
   - If test still fails, fix implementation until it passes

6. **Run all tests (REGRESSION phase)**
   - Run full test suite: `npm test`
   - **CRITICAL**: All existing tests must still pass
   - If any test fails, fix regression before proceeding
   - Verify no breaking changes to existing functionality

7. **Refactor if needed (REFACTOR phase)**
   - If code can be improved, refactor while keeping tests green
   - Run tests after each refactoring step
   - Maintain test coverage

8. **Manual testing (optional but recommended)**
   - Test in Obsidian environment if applicable
   - Verify feature works as expected in real usage
   - Check error handling
   - Test edge cases manually

9. **Write report**
   - Brief report of work done
   - What feature was implemented
   - Which files were created/modified
   - How to test the feature

### Report Structure Example for New Features

```markdown
## Feature: [brief description]

### Implementation
1. Created `ChatInput.tsx` component with @ file mention support
2. Added `FileContext` interface in `types/index.ts`
3. Integrated with `ChatManager` for file context handling
4. Tested in Obsidian - autocomplete works correctly

### Changed Files
- `src/components/ChatInput.tsx` - new component
- `src/types/index.ts` - added FileContext interface
- `src/core/ChatManager.ts` - added file context handling
```

## Bug Fixes (TDD Approach)

### Mandatory Workflow for Bug Fixes

**CRITICALLY IMPORTANT**: When user asks to fix a bug (using words "–±–∞–≥", "bug", "–æ—à–∏–±–∫–∞", "error", "–∏—Å–ø—Ä–∞–≤–∏—Ç—å", "fix"), **always** follow this TDD workflow:

**Do not skip any step!** Always follow order: reproduce ‚Üí write test ‚Üí verify test fails ‚Üí fix ‚Üí verify test passes ‚Üí run all tests ‚Üí report.

### Step-by-step TDD Process for Bug Fixes

1. **Reproduce bug**
   - Understand what the bug is
   - Reproduce in Obsidian environment or test environment
   - Identify root cause
   - Check related code

2. **Write test that reproduces bug (RED phase)**
   - Create or update test file in `tests/` directory
   - Write test that demonstrates the bug
   - Test should fail because of the bug
   - Follow test structure from @testing.mdc
   - Use descriptive test name like "should handle X correctly when Y bug occurs"

3. **Verify test fails (RED phase)**
   - Run the test: `npm test` or `npm run test:watch`
   - **CRITICAL**: Test MUST fail at this stage (reproducing the bug)
   - Verify failure matches the bug behavior
   - If test passes, bug might be already fixed or test is wrong

4. **Fix code (GREEN phase)**
   - Write code that fixes bug
   - Follow rules from @code-style.mdc and @architecture.mdc
   - Keep fix minimal and focused
   - Don't add unnecessary changes

5. **Verify test passes (GREEN phase)**
   - Run the test again: `npm test` or `npm run test:watch`
   - **CRITICAL**: Test MUST pass now (bug is fixed)
   - Verify all assertions in test are satisfied
   - If test still fails, fix implementation until it passes

6. **Run all tests (REGRESSION phase)**
   - Run full test suite: `npm test`
   - **CRITICAL**: All existing tests must still pass
   - If any test fails, fix regression before proceeding
   - Verify no breaking changes to existing functionality

7. **Manual verification (optional but recommended)**
   - Test in Obsidian environment
   - Verify bug is fixed in real usage
   - Check no regressions
   - Test related functionality

8. **Write report**
   - Brief report of work done
   - What was fixed
   - Root cause (if identified)
   - How to verify fix

### Report Structure Example for Bug Fixes

```markdown
## Bug Fix: [brief description]

### Problem
[Bug description and reproduction steps]

### Solution
1. Fixed `LLMClient.ts` - added proper error handling for network timeouts
2. Updated `Chat.tsx` - show error message to user
3. Tested in Obsidian - errors now display correctly

### Changed Files
- `src/core/LLMClient.ts` - added timeout handling
- `src/components/Chat.tsx` - added error display
```

## TDD Workflow Example

### Example: Adding a new method to ChatManager

**Feature**: Add method to get message count from current session

**Step 1: Write test (RED)**
```typescript
// tests/core/ChatManager.test.ts
describe('getMessageCount', () => {
  test('should return 0 for empty session', () => {
    chatManager.startSession(CHAT_MODES.ASK, 'gpt-4');
    expect(chatManager.getMessageCount()).toBe(0);
  });

  test('should return correct count after adding messages', async () => {
    chatManager.startSession(CHAT_MODES.ASK, 'gpt-4');
    await chatManager.sendMessage('Hello');
    expect(chatManager.getMessageCount()).toBe(2); // system + user
  });
});
```

**Step 2: Verify test fails (RED)**
```bash
npm test
# ‚ùå Test fails: getMessageCount is not a function
```

**Step 3: Implement minimal code (GREEN)**
```typescript
// src/core/ChatManager.ts
getMessageCount(): number {
  const session = this.getCurrentSession();
  return session ? session.messages.length : 0;
}
```

**Step 4: Verify test passes (GREEN)**
```bash
npm test
# ‚úÖ Test passes: getMessageCount returns correct count
```

**Step 5: Run all tests (REGRESSION)**
```bash
npm test
# ‚úÖ All tests pass - no regressions
```

**Step 6: Refactor if needed (REFACTOR)**
- Code is already clean, no refactoring needed

## Implementation Order

### When Adding New Components

Follow architecture layers from @architecture.mdc:

1. **Layer 1**: Core services (LLMClient, MessageRepository)
2. **Layer 2**: Business logic (ChatManager)
3. **Layer 3**: React components
4. **Layer 4**: Integration (main.ts, AgentView)

### When Adding New Features to Existing Components

1. Check if feature belongs to existing component
2. If new component needed, follow implementation order
3. Update types/interfaces first
4. Implement component
5. Integrate with parent components

## Code Review Checklist

Before considering work complete:

- [ ] **TDD workflow followed**: Test written first, verified to fail, then implementation
- [ ] **Tests pass**: All new tests pass
- [ ] **No regressions**: All existing tests still pass (`npm test`)
- [ ] Code follows @code-style.mdc rules
- [ ] Architecture boundaries respected (@architecture.mdc)
- [ ] TypeScript types are correct
- [ ] Error handling is in place
- [ ] Tested in Obsidian environment (if applicable)
- [ ] No console errors
- [ ] Comments are in English
- [ ] Empty line at end of files

## Obsidian-Specific Testing

### Manual Testing Steps

1. **Build plugin**: `npm run build`
2. **Load in Obsidian**: Enable plugin in settings
3. **Test functionality**: Use feature as user would
4. **Check console**: Look for errors in Obsidian console
5. **Test settings**: Verify settings save/load correctly
6. **Test view**: Open sidebar view, test interactions

### Common Issues to Check

- View registration works
- Settings persist correctly
- File operations work (reading vault files)
- React components render correctly
- API calls work (check network tab)
- Error messages display to user

## References

@SPECIFICATION.md
@architecture.mdc
@code-style.mdc
@implementation-order.mdc
@testing.mdc
